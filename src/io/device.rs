use crate::{
    common::driver::WduDriver, strings::unicode::str::WduUnicodeStr,
    strings::unicode::string::WduUnicodeString,
};
use core::ffi::c_void;
use snafu::Snafu;
use windows_sys::{
    Wdk::{
        Foundation::{DEVICE_OBJECT, DRIVER_OBJECT},
        System::SystemServices::{
            IoCreateDevice, IoCreateSymbolicLink, IoDeleteDevice, IoDeleteSymbolicLink,
        },
    },
    Win32::{
        Foundation::{NTSTATUS, STATUS_SUCCESS},
        System::Ioctl::{
            FILE_DEVICE_ACPI, FILE_DEVICE_DISK_FILE_SYSTEM, FILE_DEVICE_FILE_SYSTEM,
            FILE_DEVICE_MASS_STORAGE, FILE_DEVICE_UNKNOWN,
        },
    },
};

#[derive(Debug, Snafu)]
pub enum WduDeviceError {
    #[snafu(display("Unable to create device. Status {status}"))]
    CreateError { status: NTSTATUS },
    #[snafu(display("Invalid builder state! Must set DriverObject"))]
    InvalidBuilderState,
    #[snafu(display("Error. Status {status}"))]
    GenericError { status: NTSTATUS },
}

pub type WduDeviceResult<T> = Result<T, WduDeviceError>;

// TODO: Complete
#[derive(Clone, Copy)]
pub enum WduDeviceType {
    ACPI,
    DiskFileSystem,
    Disk,
    FileSystem,
    MassStorage,
    Unknown,
}

impl Into<u32> for WduDeviceType {
    fn into(self) -> u32 {
        match self {
            WduDeviceType::ACPI => FILE_DEVICE_ACPI,
            WduDeviceType::DiskFileSystem => FILE_DEVICE_DISK_FILE_SYSTEM,
            WduDeviceType::Disk => 0x00000007,
            WduDeviceType::FileSystem => FILE_DEVICE_FILE_SYSTEM,
            WduDeviceType::MassStorage => FILE_DEVICE_MASS_STORAGE,
            WduDeviceType::Unknown => FILE_DEVICE_UNKNOWN,
        }
    }
}

#[derive(Clone, Copy)]
pub enum WduDeviceChars {
    None,
    RemovableMedia,
    ReadOnly,
    WriteOnce,
    Remote,
    Mounted,
    VirtualVolume,
    AutoGeneratedName,
    SecureOpen,
    AllowAppContainerTraversal,
    PortableDevice,
    RequireSecCheck,
}

impl Into<u32> for WduDeviceChars {
    fn into(self) -> u32 {
        match self {
            WduDeviceChars::None => 0x0,
            WduDeviceChars::RemovableMedia => 0x1,
            WduDeviceChars::ReadOnly => 0x2,
            WduDeviceChars::WriteOnce => 0x8,
            WduDeviceChars::Remote => 0x10,
            WduDeviceChars::Mounted => 0x20,
            WduDeviceChars::VirtualVolume => 0x40,
            WduDeviceChars::AutoGeneratedName => 0x80,
            WduDeviceChars::SecureOpen => 0x100,
            WduDeviceChars::AllowAppContainerTraversal => 0x20000,
            WduDeviceChars::PortableDevice => 0x40000,
            WduDeviceChars::RequireSecCheck => 0x100000,
        }
    }
}

pub struct WduDevice {
    device_type: WduDeviceType,
    characteristics: WduDeviceChars,
    exclusive: bool,
    device: *const DEVICE_OBJECT,
}

impl Default for WduDevice {
    fn default() -> Self {
        WduDevice {
            device_type: WduDeviceType::Unknown,
            characteristics: WduDeviceChars::None,
            exclusive: false,
            device: core::ptr::null(),
        }
    }
}

impl WduDevice {
    pub(crate) fn wrap_device(device: *const DEVICE_OBJECT) -> Self {
        let mut wrapper = WduDevice::default();
        wrapper.device = device as *mut _;
        wrapper
    }

    pub fn device(&self) -> *const DEVICE_OBJECT {
        self.device
    }

    pub fn device_as_mut(&self) -> *mut DEVICE_OBJECT {
        self.device as *mut _
    }

    fn device_extension(&self) -> *mut c_void {
        unsafe { (*self.device).DeviceExtension }
    }

    pub(crate) fn get_driver(&self) -> *const DRIVER_OBJECT {
        unsafe { (*self.device).DriverObject }
    }

    pub fn exclusive(mut self, exclusive: bool) -> Self {
        self.exclusive = exclusive;
        self
    }

    pub fn device_type(mut self, device_type: WduDeviceType) -> Self {
        self.device_type = device_type;
        self
    }

    pub fn characteristics(mut self, characteristics: WduDeviceChars) -> Self {
        self.characteristics = characteristics;
        self
    }

    // TODO: Create WduDeviceFlags
    pub fn set_flags(&mut self, flags: u32) {
        unsafe {
            (*self.device_as_mut()).Flags |= flags;
        }
    }

    // TODO: Consider if we store a copy of device_name
    pub fn build<T>(
        mut self,
        driver: &WduDriver,
        device_name: Option<&WduUnicodeStr>,
    ) -> WduDeviceResult<Self> {
        // I don't like this
        let name = device_name.map_or_else(|| WduUnicodeStr::default().into(), |name| name.into());
        let ext_size = core::mem::size_of::<WduDevice>() + core::mem::size_of::<T>();
        let status = unsafe {
            IoCreateDevice(
                driver.as_ptr(),
                ext_size as u32,
                &name,
                self.device_type.into(),
                self.characteristics.into(),
                u8::from(self.exclusive),
                &mut self.device as *mut _ as *mut _,
            )
        };

        if status != STATUS_SUCCESS {
            return Err(WduDeviceError::CreateError { status });
        }

        let ext = self.device_extension();
        unsafe {
            // Copy WduDevice to the our piece of the device extension so we have a reference to it.
            ext.copy_from(
                &self as *const WduDevice as *const _,
                core::mem::size_of::<WduDevice>(),
            );
        }

        Ok(self)
    }

    pub fn delete(&self) {
        if !self.device.is_null() {
            unsafe { IoDeleteDevice(self.device) }
        }
    }

    pub fn symbolic_name(
        &self,
        device_name: &WduUnicodeStr,
        symbolic_name: &WduUnicodeStr,
    ) -> WduDeviceResult<()> {
        let status = unsafe { IoCreateSymbolicLink(&symbolic_name.into(), &device_name.into()) };

        if status != STATUS_SUCCESS {
            return Err(WduDeviceError::GenericError { status });
        }

        Ok(())
    }

    pub fn delete_symbolic_name(symbolic_name: &WduUnicodeStr) -> WduDeviceResult<()> {
        let status = unsafe { IoDeleteSymbolicLink(&symbolic_name.into()) };

        if status != STATUS_SUCCESS {
            return Err(WduDeviceError::GenericError { status });
        }

        Ok(())
    }

    pub(crate) fn get_wdu_device<'a>(device: *const DEVICE_OBJECT) -> &'a WduDevice {
        unsafe {
            let dev_ext = (*device).DeviceExtension;
            core::mem::transmute(dev_ext)
        }
    }

    pub fn extension_as_ref<T>(&self) -> &T {
        let mut dev_ext = self.device_extension();
        unsafe {
            dev_ext = dev_ext.wrapping_add(core::mem::size_of::<WduDevice>());
            core::mem::transmute(dev_ext)
        }
    }

    pub fn extension_as_mut_ref<T>(&self) -> &mut T {
        let mut dev_ext = self.device_extension();
        unsafe {
            dev_ext = dev_ext.wrapping_add(core::mem::size_of::<WduDevice>());
            core::mem::transmute(dev_ext)
        }
    }

    // We use read to take ownership of the interior data so we can properly call any allocated
    // memory that we might be storing inside the DeviceExtension. We use read because we don't
    // own the data where the device extension is allocated, the IO manager will deallocate the
    // DeviceExtension once the device is deleted.
    pub fn extension<T>(&self) -> T {
        let mut dev_ext = self.device_extension();
        unsafe {
            dev_ext = dev_ext.wrapping_add(core::mem::size_of::<WduDevice>());
            core::ptr::read(dev_ext as *const _)
        }
    }

    pub fn extension_as_ptr<T>(&self) -> *const T {
        let mut dev_ext = self.device_extension();
        unsafe { dev_ext.wrapping_add(core::mem::size_of::<WduDevice>()) as *const _ }
    }

    pub fn extension_as_mut_ptr<T>(&self) -> *mut T {
        let mut dev_ext = self.device_extension();
        unsafe { dev_ext.wrapping_add(core::mem::size_of::<WduDevice>()) as *mut _ }
    }
}
